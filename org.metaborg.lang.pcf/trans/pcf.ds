module pcf

imports

  nabl2/runtime/interpreter/scopegraph-impl

  ds-signatures/PCF-sig
  ds-signatures/Desugared-sig

  analysis/base
  analysis/functions
  analysis/lets

signature

  sorts V constructors
    NumV     : Int -> V
    ClosureV : Env * String * Expr -> V
    FixV     : String * V -> V

  sort aliases
    Env = Map(String, V)

  arrows
    Start -init-> V
    Expr --> V
 
  native operators
    parseI    : String -> Int
    addI      : Int * Int -> Int
    subtractI : Int * Int -> Int
    multiplyI : Int * Int -> Int
    divideI   : Int * Int -> Int

  variables
    E : Env
    v : V

rules

  s@Start(e) -init-> v
    where NaBL2(s) -init-> _;
          Env {} |- e --> v.

  Const(i) --> NumV(parseI(i)).
 
  Subtract(NumV(i), NumV(j)) --> NumV(subtractI(i, j)).

  BinExpr(NumV(i1), Plus(), NumV(i2)) --> NumV(addI(i1, i2)).
  BinExpr(NumV(i1), Minus(), NumV(i2)) --> NumV(subtractI(i1, i2)).
  BinExpr(NumV(i1), Times(), NumV(i2)) --> NumV(multiplyI(i1, i2)).
  BinExpr(NumV(i1), DividedBy(), NumV(i2)) --> NumV(divideI(i1, i2)).

  E |- Ref(x) --> E[x].
  //where pathOf(Occurrence("NS",x,index)) => p,
  //      deref(p,f) => v. // [E(P),N(I,_),D(_)]

  Ifz(NumV(0), v, _) --> v.
  Ifz(NumV(i), _, v) --> v
    where i != 0.

  E |- fun@Fun(x, e) --> ClosureV(E, x, e)
    where fun -paramsOf-> s;
          fun -typeOf-> ty.

  App(ClosureV(E, x, e), v) --> v'
    where Env {x |--> v, E} |- e --> v'.

  Fix(fun, e) --> FixV(fun, e).

  App(fix@FixV(fun, ClosureV(E, x, e)), v) --> v'
  where Env {fun |--> fix, x |--> v, E} |- e --> v'.
 
  E |- Let(x, v1, e) --> v2
    where Env {x |--> v1, E} |- e --> v2.
