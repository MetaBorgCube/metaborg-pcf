module analysis/base

imports

  signatures/-

signature

  constraint generator

    // scope parameters and (optionally) type per syntactic sort
    [[ Start ^ (scope)        ]]
    [[ Expr  ^ (scope) : type ]]

  name resolution

    // edge label set
    labels
      P I

    // partial order for the labels
    // NB. for now implied pairs are not calculated,
    //     so make sure to be complete. E.g. in the case of
    //     X < Y, Y < Z you must add X < Z as well.
    order
      D < I,
      D < P,
      I < P

    // specify well-formedness regex
    well-formedness
      P* . I*

  types
    TInt()           
    TFun(type, type)

rules

  init ^ (s) :=
    new s.

  [[ Start(e) ^ (s) ]] :=
    [[ e ^ (s) : ty ]].

rules

  [[ Const(_) ^ (_) : TInt() ]] :=
    true.

  [[ Ifz(c,t,f) ^ (s) : ty ]] :=
    [[ c ^ (s) : TInt() ]],
    [[ t ^ (s) : ty ]],
    [[ f ^ (s) : ty ]].

  [[ BinExpr(e1,_,e2) ^ (s) : TInt() ]] :=
    [[ e1 ^ (s) : TInt() ]],
    [[ e2 ^ (s) : TInt() ]].

