module pcf

signature
  sorts ID  = string                        // $x$
  sorts INT = string                        // $n$

  sorts Start constructors
    Start : Expr -> Start

  sorts Name constructors
    Id : ID -> Name

  sorts Expr constructors                   // $e$ :=
    Const    : INT -> Expr                  //      | $n$
    Ref      : Name -> Expr                 //      | $x$
    Ifz      : Expr * Expr * Expr -> Expr   //      | ifz $e$ then $e$ else $e$
    Fun      : Name * Expr -> Expr          //      | fun ($x$ : $te$) { $e$ }
    Fix      : Name * Expr -> Expr          //      | fix ($x$ : $te$) { $e$ }
    App      : Expr * Expr -> Expr          //      | $e$ $e$
    Let      : Name * Expr * Expr -> Expr   //      | let $x$ = $e$ in $e$
    Add      : Expr * Expr -> Expr          //      | $e$ + $e$
    Subtract : Expr * Expr -> Expr          //      | $e$ - $e$
    Multiply : Expr * Expr -> Expr          //      | $e$ * $e$
    Divide   : Expr * Expr -> Expr          //      | $e$ / $e$
    LetPar   : list(Bind) * Expr  -> Expr   //      | letpar $b*$ in $e$
    LetRec   : list(Bind) * Expr  -> Expr   //      | letrec $b*$ in $e$
    LetSeq   : list(Bind) * Expr  -> Expr   //      | letseq $b*$ in $e$

  sorts Bind constructors                   // $b$ :=
    Bind : Name * Expr -> Bind              //      | $x$ = $e$

  sorts TypeExp constructors                // $te$ :=
    NumType : TypeExp                       //       | num
    FunType : TypeExp * TypeExp -> TypeExp  //       | $te$ -> $te$

  sorts Type constructors
    NUM : Type
    FUN : Type * Type -> Type

  relations
    typeOfDecl : occurrence -> Type

  namespaces
    Var  : string
    Type : string

  name-resolution
    labels P R
    resolve Var filter pathMatch[P*] min pathLt[$ < P]

rules

  programOk : Start

  programOk(Start(e)) :- {s} new s,
    typeOfExpr(s, e) == _.

rules

  typeOfExpr : scope * Expr ->  Type

  typeOfExpr(s, Const(_)) = NUM().

  typeOfExpr(s, Ref(Id(x))) = T :-
    Var{x@x} in s |-> [(_, _)],
    typeOfDecl of Var{x@x} in s |-> [(_, (_, T))].

  typeOfExpr(s, Ifz(e1, e2, e3)) = ty :-
    typeOfExpr(s, e1) == NUM(),
    typeOfExpr(s, e2) == ty,
    typeOfExpr(s, e3) == ty.

  typeOfExpr(s, Fun(Id(x), e)) = FUN(S, T) :- {s_fun}
    new s_fun, s_fun -P-> s,
    s_fun -> Var{x@x} with typeOfDecl S,
    typeOfExpr(s_fun, e) == T.

  typeOfExpr(s, Fix(Id(x), e)) = FUN(T, T) :- {s_fix}
    new s_fix, s_fix -P-> s,
    s_fix -> Var{x@x} with typeOfDecl FUN(T, T),
    typeOfExpr(s_fix, e) == FUN(T, T).

  typeOfExpr(s, App(e1, e2)) = T :- {S U}
    typeOfExpr(s, e1) == FUN(S, T),
    typeOfExpr(s, e2) == U,
    U == S.

  typeOfExpr(s, Let(Id(x), e1, e2)) = T :- {s_let U}
    typeOfExpr(s, e1) == U,
    new s_let, s_let -P-> s,
    s_let -> Var{x@x} with typeOfDecl U,
    typeOfExpr(s_let, e2) == T.

  typeOfExpr(s, Add(e1, e2)) = NUM() :-
    typeOfExpr(s, e1) == NUM(),
    typeOfExpr(s, e2) == NUM().

  typeOfExpr(s, Subtract(e1, e2)) = NUM() :-
    typeOfExpr(s, e1) == NUM(),
    typeOfExpr(s, e2) == NUM().

  typeOfExpr(s, Multiply(e1, e2)) = NUM() :-
    typeOfExpr(s, e1) == NUM(),
    typeOfExpr(s, e2) == NUM().

  typeOfExpr(s, Divide(e1, e2)) = NUM() :-
    typeOfExpr(s, e1) == NUM(),
    typeOfExpr(s, e2) == NUM().

rules

  typeOfExpr(s, LetPar(binds, e)) = T :- {s_let}
    new s_let, s_let -P-> s,
    parBindsOK(s, s_let, binds),
    T == typeOfExpr(s_let, e).

  parBindsOK : scope * scope * list(Bind)

  parBindsOK(s, s_let, []).

  parBindsOK(s, s_let, [Bind(Id(x), e)|binds]) :- {T}
    typeOfExpr(s, e, T),
    s_let -> Var{x@x} with typeOfDecl T,
    parBindsOK(s, s_let, binds).

rules

  typeOfExpr(s, LetRec(binds, e)) = T :- {s_let}
    new s_let, s_let -P-> s,
    recBindsOK(s_let, binds),
    typeOfExpr(s_let, e) == T.

  recBindsOK : scope * list(Bind)

  recBindsOK(s, []).

  recBindsOK(s, [Bind(Id(x), e)|binds]) :- {T}
    typeOfExpr(s, e, T),
    s -> Var{x@x} with typeOfDecl T,
    recBindsOK(s, binds).

rules

  typeOfExpr(s, LetSeq(binds, e)) = T :- {s_let}
    seqBindsOK(s, binds) == s_let,
    typeOfExpr(s_let, e) == T.

  seqBindsOK : scope * list(Bind) -> scope

  // FIXME Patterns are not properly linearized, so the short version
  //       does not work corectly
//seqBindsOK(s, []) = s.
  seqBindsOK(s, []) = s' :- s' == s.

  seqBindsOK(s, [Bind(Id(x), e)|binds]) = s''  :- {s' T}
    typeOfExpr(s, e) == T,
    new s', s' -P-> s,
    s' -> Var{x@x} with typeOfDecl T,
    seqBindsOK(s', binds) == s''.
